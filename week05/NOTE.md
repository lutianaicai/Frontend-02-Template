# 第五周学习总结

## CSS计算

### 收集规则

* 遇到 style 标签，把 CSS 规则保存
* 利用 CSS parser 分析规则

### 添加调用

* 创建一个元素，立即计算 CSS
* 案例按照分析元素时，所有 CSS 规则已经收集完毕来考虑
* 实际浏览器 style 可能写在 body 里，CSS需要重新计算

### 获取父元素序列

* 在 coputeCSS 函数中，必须知道元素的所有父元素才能判断元素 与规则是否匹配
* 添加调用时的 stack 可以获取，匹配顺序从内向外

div div #myid -> 一定匹配当前元素 div 则不知道

### 选择器与元素匹配

* 选择器也要从当前元素向外排列
* 复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列

### 计算选择器与元素匹配

* 根据选择器类型和元素属性，计算是否与当前元素匹配
* 案例仅三种基本选择器，实际浏览器要处理复合选择器

### 生成 computed 属性

* 一旦确定匹配，就应用到选择器的元素上，形成 computedStyle

### specificity 的计算逻辑

* CSS 规则根据 specificity 和后来优先规则覆盖
* specificity 是个四元组，越左边权重越高
* 一个 CSS 规则的 specificity 根据包含的简单选择器相加而成

## 排版

### 收集元素进行

* 根据主轴尺寸，把元素分进行
* 若设置了 no-wrap，则强行分配进第一行

### 计算主轴

* 找出所有 Flex 元素
* 把主轴方向的剩余尺寸按比例分配给这些元素
* 若剩余空间为负，所有 flex 元素为0，等比压缩剩余元素

### 计算交叉轴

* 根据每一行中最大元素尺寸计算行高
* 根据行高 flex-align 和 item-align，确定元素具体位置

## 渲染

### 绘制单个元素

* 绘制图形环境由 npm 包 images 提供
* 绘制在 viewport 上进行
* render.js 中对 background-color 进行判断并渲染输出图片

### 绘制 DOM 树

*	递归调用子元素绘制方法完成对 DOM 树的绘制
*  忽略不需要绘制的节点
* 	实际浏览器中，文字绘制，涂层 compositing 都是难点

